#!/usr/bin/env perl

use FindBin;
use lib "$FindBin::Bin/../lib";
use App::Netdisco;

# for netdisco app config
use Dancer qw/:moose :script/;

# callbacks and local job queue management
use App::Netdisco::Daemon::Queue ':all';

# needed to quench AF_INET6 symbol errors
use NetAddr::IP::Lite ':lower';

# set temporary MCE files' location in home directory
use Path::Class 'dir';
my $tmp_dir = ($ENV{NETDISCO_TEMP} || dir($ENV{HOME}, 'tmp'));
mkdir $tmp_dir if ! -d $tmp_dir;

use MCE;
use Role::Tiny::With;

my $mce = MCE->new(
  spawn_delay => 0.15,
  job_delay   => 0.15,
  tmp_dir     => $tmp_dir,
  user_func    => sub { $_[0]->worker_body },
  on_post_exit => \&restart_worker,
  user_tasks   => build_tasks_list(),
)->run();

sub build_tasks_list {
  my $tasks = [{
    max_workers => 1,
    user_begin => worker_factory('Manager'),
  }];

  set(daemon_pollers => 2)
    if !defined setting('daemon_pollers');
  set(daemon_interactives => 2)
    if !defined setting('daemon_interactives');

  # XXX MCE does not like max_workers => 0

  push @$tasks, {
    max_workers => setting('daemon_pollers'),
    user_begin => worker_factory('Poller'),
  } if setting('daemon_pollers');

  push @$tasks, {
    max_workers => setting('daemon_interactives'),
    user_begin => worker_factory('Interactive'),
  } if setting('daemon_interactives');

  return $tasks;
}

sub worker_factory {
  my $role = shift;
  return sub {
    my $self = shift;

    # my $wid = $self->wid;
    # $self->sendto('stderr', ">>> worker $wid starting with role $role\n");
    Role::Tiny->apply_roles_to_object($self, "App::Netdisco::Daemon::Worker::$role");

    $self->worker_begin if $self->can('worker_begin');
  };
}

sub restart_worker {
  my ($self, $e) = @_;
  reset_jobs($e->{wid});
  $self->restart_worker($e->{wid});
}
